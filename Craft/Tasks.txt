Done:
* Gør det muligt at tegne polylines lige som polygon
* Lav det sådan, at ScatterChartViewModel abonnerer på at world window ændrer sig, og når det sker,
  så opdaterer den de punkter, der tegnes
* ScatterChartViewModel skal ikke selv lave punkter men gøre brug af en callback
* Der er en problematik i at ViewportSize først kendes et stykke inde i runtime, og det gør, at man ikke umiddelbart kan 
  placere Uppef Left Corner for World Window, når man har at gøre med en matematisk view model.
  Man kunne måske abonnere på ViewPortSize, og når så den skifter første gang og vel at mærke ikke er 0, 0, så
  sætter man WorldWindow Size samt x- og y-skalering.
  I øjeblikket så sætter du skalering samt initiel position af upper left corner of World Window i constructoren for view modellen.
  Var det mon ikke lige så naturligt at sætte det VINDUE, som du gerne ville operere med i World Window...
  .. Det burde i hvert fald være sådan at du sætter noget, der er uafhængigt af viewport size, som du jo principielt ikke kender.
  For et ALMINDELIGT view, er det naturligt at sige, at origo skal være i øverste venstre hjørne, og for et MATEMATISK er det naturligt
  at sige, at det skal være i NEDERSTE venstre hjørne.
  Det er vel også naturligt at sætte magnification til 1, men det er vel LIGE så naturligt at sætte den ønskede World Window Placering
  og så lade computeren beregne den skalering, der så passer...
  I øvrigt - du kunne helt droppe at have en "matematisk" variant af viewet. I stedet kunne du give den et sæt af basisvektorer for 
  koordinatsystemet, som pr default er (1, 0) og (0, 1). For det matematiske skulle basisvektorerne så være (1, 0) og (0, -1). På den måde 
  kunne du også lade f.eks. 4. kvadrant være den, du tegnede ting i, selv om det sjældent vil være relevant i praksis
* Der skal skelnes mellem minor og major updates af World Window. Minor haves for hver mouse move under panorering.
  Major haves når man zommer ind eller ud eller slipper museknappen under panorering. Det er kun i forbindelse med
  major updates, at man vil skulle hente data fra en datakilde.
* Find ud af hvorfor du opdaterer PointViewModels hele tiden fremfor at transformere med magnification
  - det sidste burde kunne lade sig gøre
  -> Der burde jo ikke være stor forskel på ShapeViewModel og PointViewModel. Brugeroplevelsesmæssigt, så ændrer punkternes størrelse sig ikke
     uanset scaling. Bemærk, at du bruger et væld af forskellige teknikker til positionering af forskellige ting:
     - RenderTransform (med transformations-matricen) for polygoner, polylines, lines
     - ShapePositionConverter for shapes (du vil gerne sætte Canvas.Left og Canvas.Top)
     - PointPositionConverter for points
* Labels på plads - dvs noget tekst, der lige som points bibeholder størrelse uanset skalering
* Klikke på et punkt i et koordinatsystem og få information om, hvad der er klikket på
* Refaktorer tegning af grid lines, så der tegnes så mange, at der ikke opstår "tomme" områder under panorering
* Det fungerer fint med at lade en transformation afgøre placeringen af labels, men mon ikke man kunne slå x eller y fra, eller bare override med en viewport koordinat?
  på den måde burde du kunne vise labels hele tiden - også når du panorerer, og så ville du slippe for det der med at skulle skjule labels
* Når man aktiverer tracking af den der value of interest, så hopper labels hen det forkert sted (fixed)
* Labels bør tegnes af CoordinateSystemViewet (og også de der margener - indtil videre har du dem kun i den bagvedliggende GeometryEditorViewModel, fordi du vil have labels foran)
  -> Mnjoooh - du har fundet en fin løsning, hvor de stadig tegnes af GeometryEditorViewModel, og hvor du bruger en value converter, der tillader override af x eller y værdi med en viewport koordinat
* Når man er i tracking mode, svarer det til panorering, hvor der f.eks. ikke tegnes nye gridlines. 
  Derfor driver den på et tidspunkt ud i det tomme område, hvor der ikke er tegnet noget.
  Løsning: Den skal vedligeholde en variabel, der beskriver, hvor tæt den er på det vindue, der fremkommer ved at udvide world window i forbindelse 
  med tegning af gridlines. Når så den er tæt på kanten, skal den kalde samme funktion, som kaldes fra Major Update.
  Det kunne passende laves generelt, så det også kunne bruges i f.eks. spil.. og altså ikke være en del af CoordinateViewModel...
  Indtil videre ligger det faktisk bare i Tab3ViewModel, der har en timer, og så er det den, der opdaterer det, der pt hedder DynamicXValue
  og bagefter sætter World Window positionen. Husk i øvrigt lige på, at det altså er CoordinateSystemViewModellen, der tegner de der grid lines
  under anvendelse af GeometryEditorViewModellens general purpose funktionalitet, så måske er det meget naturligt, at det er den, der afgør,
  hvornår der skal gentegnes. Men hold lige fat i ideen - du vil jo f.eks. gerne lave noget Zelda-style sceneskift, som ikke afhænger af 
  CoordinateViewModellen..
* Mht at fokusere på en dynamisk værdi, så skal det ikke nødvendigvis være i midten
* Når der tegnes en collection af linier, så skal det ske i viewport-koordinater, for det er ikke til at styre med transformation og thickness for linierne
  - det må gerne foregå på samme måde som det gør med labels, så det gentegnes, når man bevæger sig uden for World Window
  .. I øvrigt.. det med at opdatere StaticXValue - det sker, hver gang der sker en opdatering af World Window, dvs rigtig ofte, f.eks. ved hver mouse move
     event under panorering. Det er ikke hensigtsmæssigt at cleare/genpopulere den der observable collection of coordinates så ofte - så er det væsentligt 
     bedre at lade data templaten basere sig på en transformation, lige som det i øvrigt allerede foregår for koordinatakse labels (I øvrigt bør koordinatakse
     labels altså håndteres af Coordinate System View Modellen og ikke GeometryEditorViewModellen)
     .. Mht beregning af X for de lodrette linier, så skal der bindes til noget i stil med hvad der allerede sker for labels eller måske mere simpelt
     .. Du burde altså lave nogle mere generelle konstruktioner, der også dækker f.eks. gridlines, så de ikke skal tegnes skaleres, men bare tegnes med
        en thickness defineret i viewport koordinater. Bemærk, at det jo så skal gælde for GeometryEditorViewModel generelt snarere end at være specielt
        for coordinate system view modellen. Måske kunne du gribe det sådan an, at der i GeometryEditorViewModel altid skal tegnes et kvadrat med hjørner i 
        (0, 0) og (1, 1)
     .. Husk, du bruger et væld af teknikker i situationer, hvor gerne vil undgå at skalere. F.eks. for points, som du jo gerne vil vise i samme størrelse
        uanset hvad scaling er sat til. Du har nok gavn af at dokumentere det i et eller andet omfang.
* Vis en linie for en dynamisk X-værdi i CoordinateSystemView
  - Der skal være 2 modes: 
    1) hvor den er lige så fast som Y-aksen, dvs hvis den ændrer sig, så flyttes World Window
    2) En, hvor den opdateres uafhængigt af World Window
  - Man skal kunne sætte X-værdien og så skal den selv omregne til Viewport koordinater
* Det skal kunne slås fra at man tegner horisontale og/eller vertikale grid lines
* Visualisering af samling af "timestamps of interest"
* GeometryEditorViewModel skal publicere et event om at der klikkes et sted
* Hvis man for coordinateViewModel er i det mode, hvor World Window følger en dynamisk variabel, så skal man ikke tegne
  linien ved hvert refresh - den skal tegnes "statisk" på lige for med koordinatsystemets akser.
* Mulighed for at "låse" WorldWindow til et interval på y-aksen, så det ikke ændres, når man panorerer eller zoomer
* Bedre granularitet, når man zoomer ind på en tidsakse
* Man skal kunne sige til GraphViewModel hvor de forskellige punkter skal placeres
* Grid lines og kurver skal have samme tykkelse uanset magnification
* Klikke på et punkt i time series viewet og få vist det som en linie
* Man skal kunne sætte World Window under runtime og ikke bare under opstart
* Man skal kunne starte med et World Window, der fylder hele viewporten ud, hvor scaling X og scaling Y sættes hver for sig i stedet for at være ens
* Tidskurven skal tegnes pænere, så man transformerer punkter og BAGEFTER tegner, fremfor at skalere selve kurven i vildskab
  - Når skalering ændres, skal "Points" propertyen for de PolylineViewModels, man har, genberegnes. Når man panorerer,
    skal der opdateres en translations-matrix.
  - PolyLineViewModel skal have en ekstra property, der udtrykker koordinaterne i Viewport koordinater
    -> Måske skal du have 2 forskellige specialiseringer af en abstrakt basisklasse
* Du burde kunne lave dit hex map på samme måde som når du tegner pixels, dvs hvor du bruger et uniformgrid.
  Yes - der er noget proof of concept i Tab6View
* Prøv i handleren for tick eventet at sætte World Window således at XValue Of Interest er i midten
  - Når man panorerer i vinduet, skal den holde op med at autoopdatere world vinduet (OK)
  - Når den automatisk flytter world window, så svarer det til, at man panorerer, dvs grid lines og labels flytter ikke med - det ser ikke godt ud
    .. det kunne være fint, hvis man lige holdt styr på, hvor langt den var kravlet og så "emulerede", at den laver en major update med jævne mellemrum
* Tilføj en ObservableObject for MouseWorldPosition - ovevej senere at erstatte Dependency propertyen
* Margenerne skal tegnes foran de almindelige labels

In progress:
* Placer SelectedRegionWindow rigtigt.
  - den skal vel bruge transformationen ligesom de almindelige shapes. De bruger i øvrigt en ItemTemplate, men det skal selected region jo ikke gøre
    i og med at den ikke indgår i en collection (ok)
  - Det virker endnu ikke rigtigt for et TimeSeriesView.. Generelt (dvs selv for et almindeligt view) lader der til at gælde, at det ikke virker,
    når der er forskellige skalering på de 2 akser
* Selected Region skal bruges til at vedligeholde et observableobject, som kan sættes udefra
* Det skal kunne konfigureres sådan at SelectedRegion går helt fra top til bund (eller fra venstre til højre) i stedet for at være et vindue
* Du skal bruge en mere simpel valueconverter for de almindelige labels
* Der skal være mulighed for at override de labels, der tegnes i margen området - særligt for y aksens labels
* Der skal stå noget meningsfyldt i bjælken under labels såsom dato, så man ikke er i tvivl om, hvilket tidsinterval man ser på
* Bemærk lige, at du i Tab3 af Craft.Algorithms.GuiTest (Line of sight) benytter en Polygon, som du binder til en "PointCollection", 
  når du tegner 3-kanter. Det står i kontrast til hvordan du tegner polygoner i GeometryEditorView, hvor du binder
  til en PolygonViewModel, som har en string property - det er nok en kende tungere end den første metode
* Refaktorer tegning af grid lines, så de tegnes med polylines i stedet for lines
* Lav CoordinateSystemViewModel sådan at WorldWindow starter ved koordinatakserne og ikke helt ude i kanten

Todo:
* Måske skal du have Undo/Redo historik på det at man ændrer selected region
* Vis koordinater for ImageEditorView, som er under Tab3
* Du bør strømline det der med MinorWindowUpdate og MajorWindowUpdate. Der er brug for at identificere, at brugeren interagerer - pt er det jo sådan,
  at MajowUpdate sker af sig selv (når man er i det mode, hvor world window bevæger sig) og i den forbindelse skal man FORBLIVE i slide mode, men når
  der kommer en major update pga at man bruger musens rullehjul for at zoome, så skal den TRÆDE UD af slide mode.
* Det kunne være nice, hvis man ikke skulle "lede" efter forekomster på tidsaksen. Der kunne være et mode, hvor den hoppede til højre eller venstre 
  og landede der, hvor der var noget. Prøv at lave noget med historiske hændelser..
* Fix det med at man ikke kan zoome med ctrl+leftclick
* Når cursoren forlader et område, skal der ikke længere vises nogen koordinater
* Der skal være et mode, hvor man kontinuert opdaterer zoom, som du har kunnet før og formentlig stadig kan med nogle kontroller
* Leg med tegning af parameterfremstillinger
* Leg med tegning af splines af forskellig art
* Brug dte til et shoot em up spil
* Saml WorldWindowSize og WorldWindowUpperLeft i en BoundingBox - så sker der ikke lige så mange opdateringer
* Undgå at tegne ting, der ligger uden for World Window
* Det kunne være fint, hvis man kunne bede GeometryEditorViewModellen om at beregne en bounding box og så sætte WorldWindow til det.
* Der er en lille fejl, når man resizer Viewporten - så hopper World Window
* Gør det muligt at tegne et koordinatsystem i MathematicalGeometryEditorViewModel
  - Det må gerne udfylde den tilgængelige plads
  - Hvis World Window ikke intersecter en akse, er det fint, hvis man somehow kan se den alligevel
* Når man exporterer grafer, så skal der kun en label på noder, der faktisk har en label
* Få gjort det færdigt med at have en label på en edge
  o en edge skal ikke bare have en data property - den skal have en ArrayList property ligesom node allerede har (OK)
* IGraph er lidt for bloated - det er f.eks. ikke hensigtsmæssigt, at den har metoderne GetNodeLabel og GetEdgeLabel. Det er sådan set heller ikke
  optimalt, at den har metoden GetCost, da edges i en graf jo altså ikke behøver at have en cost.
  Måske burde man konsekvent operere med, at f.eks. cost og labels hører til de nodes og edges, som kan hives ud af en graf.
  Der skal i øvrigt gælde, at der kan være mere end 1 edge fra en node til en anden, f.eks. med forskellige labels.
  Edges og nodes bør ikke nødvendigvis have ids.. eller hvad..
  Når du skriver en graf til fil, så traverserer du nodes, og for hver node traverserer du Neighbor ids. Så var det nok bedre at traversere
  "outgoing edges"
  o Tilføj en mulighed for at hive outgoing edges for en node (OK)
  o Lav Dijkstra-algoritmen om så den bruger den nye konstruktion (OK)
  o Fjern GetCost fra IGraph (OK)
  o Etabler et alternativ til IGraph.GetNodeLabel, så man kan få fat i noden og spørge DEN om dens label (OK)
  o Sikr at du kan eksportere til graphml med den nye mekanisme (OK)
  o Fjern GetNodeLabel fra IGraph.  (OK)

Da du skiftede fra at tegne et antal liniestykker og til at tegne en polyline, vendte den tingene på hovedet uden at du lagde mærke til det

Pt er der 2 måder at initializere sin GeometryEditor på:
1) Man angiver x skalering og y-skalering 
   (OG SÅ PLACERER DEN ORIGO I ENTEN NEDERSTE ELLER ØVERSTE VENSTRE HJØRNE)
2) Man angiver et ønsket world window
   (OG SÅ PLACERER DEN WORLD WINDOW SÅLEDES, AT DEN PASSER TIL DET, BORTSET FRA AT DET
   I REGLEN ER LIDT STØRRE, FORDI ASPECT RATIO FOR VIEW PORTEN ER ANDERLEDES OG DER DERFOR ER PLADS TIL OVERS)

Hvad er du i gang med nu?
.. at erstatte initialWorldWindowUpperLeft med initialWorldWindowFOCUS - den skulle fint kunne bruges i forbindelse med
   placering af et view på den måde, hvor man gerne vil SLIPPE for at angive skalering. Og derudover er det en fin
   parameter, når man GERNE vil angive skalering


Mht at placere World Window, så kan man indtil videre kun gøre det under Configuration Time. Der er umiddelbart 2 måder at gøre det på:
1) Man specificerer midtpunkt for WorldWindow, og derudover specificerer man horisontal og vertikal skalering. 
   Det er brugbart, hvis man ikke bekymrer sig så meget om hvor World Windowets KANTER er, men er mere interesseret i skalering og midtpunkt
2) Man specificerer midtpunkt for WorldWindow, og derudover specificerer man dets KANTER. Så sørger applikationen for at det passer med
   View Porten - det indebærer så, at X- og Y-skalering generelt bliver forskellige
3) Man specificerer midtpunkt for WorldWindow, og derudover specificerer man dets KANTER, OG man specificerer, hvad skalering af X og Y skal være.

Er det strengt nødvendigt de de der "initial"-ting? Kunne man ikke i stedet bare sætte dem, og hvis viewporten ikke er sat, så bruges de?

Det kunne være fint, hvis man bare kunne sætte properties og så fandt den selv ud af det, evt med præcedens..
->
  Hvis man sætter FOKUS, skal det respekteres
  Hvis man sætter STØRRELSEN, skal det respekteres (så sætter den selv skalering)
  Hvis man angiver, at den skal maintaine ASPECT RATIO, skal det respekteres (det trumfer i givet fald størrelsen)
  Hvis man sætter SKALERING, skal det respekteres (det trumfer i givet fald størrelsen)
->
  naah man skal altså sætte det i ét hug, så det ikke flakker

Hvad med at sige, at man kan kalde en PLACEWORLDWINDOW metode (hvornår man end har lyst). Hvis view porten er sat, når man gør det, så
virker det med det samme, og ellers gemmes tallene til når viewporten er sat, man kan også angive, at den skal kaldes hver gang viewportens størrelse ændres