Done:
* Skræl solutionen ned, så den ikke beskæftiger sig med person associations
* Skræl Person ned, så den kun har first name og surname

Todo:
* Find skal virke for disse cases (der skal være ækvivalens mellem repo og API):
  A) Arguments:
     - historical time: null 
     - include historical objects: no
     Expected: kun Chewbacca vises

  B) Arguments:
     - historical time: 01-01-2004 
     - include historical objects: no
     Expected: Chewbacca og Darth Vader vises
  
  C) Arguments:
     - historical time: null
     - include historical objects: yes
     Expected: Chewbacca og Darth Vader vises. Darth vader vises på kortet som rød
  
Kan du sige til dit eget API, at du vil have historiske personer med op?


Todo: Få det helt på plads med VIEWING af historik. Editering kan vente
* Når man indtaster tidspunkt i DatePicker-feltet så går den i uendelig løkke. Det må skyldes, at den både ændres ved bruger
  input og når man klikker nede på linealen. Løs det gerne i samme stil som dengang du havde problemet med DMI.Data.Studio,
  hvor du kun laver en opdatering, hvis den faktisk er forskellig. Måske er det nok med en guard i selve propertyen..
  Du bør jo nok få repareret SjovMedWigos, og i den forbindelse skal du have refaktoreret den, så der tages højde for det med
  at mange af persistence-funktionerne er gjort asynkrone.....
  Well den kompilerer, og kører.. kom du omkring det?
  Kan man lave objekter med den? nopes..
  Hvad sker der, når man kalder RetrieveObjects - den kører igennem, men der er åbenbart ikke nogen. Bliver der ikke seedet?
  Jo, der bliver seedet, men går det så galt, når du retriever dem?
  Det er jo desvære svært at se i fucking databasen fra en sia maskine!!

  ........Tag lige 2 steps tilbage, tag en dyb indånding, og se, hvor du er.
  Du er ved at bygge frontends af forskellig art til DFOS APIet. Du har bygget en konsol-applikation, som virker fint.
  Der var i øvrigt en del arbejde i at lave methods i Craft.Persistence asynkrone, så det både virkede, når det wrappede
  EF Core og også et API...
  Efterfølgende satte du dig for at lave en WPF baseret gui, der kunne gøre det samme. Først fik du den gode gamle
  PR-ting i spil, og derefter satte du dig for at tilpasse SjovMedWigos... Det sad du så med fredag aften på arbejdet
  og oplevede, at du ikke kunne lave en template for projektet
  Så gik du hjem og brugte en del tid i weekenden på det og kom også relativt langt, men så oplever du fandengaleme,
  at du ikke kan bygge det på din SIA-maskine, og endda, at den bare staller, når du prøver!!!
  Du have lige en hypotese om at det var fordi det var noget DotNet7, men det er SjovMEdWigos jo altså OGSÅ!





Todo:
* Hvorfor vises Anakin, endda med rød, når han jo har dateclosed i fortiden? Han vises i øvrigt også i listen, hvilket han 
  heller ikke burde.
  -> Du sender jo ikke noget historisk tidspunkt ned, så hvorfor kommer han overhovedet med op? Den går helt ned på det nederste
     repo, dvs den er ikke wrappet af en versioned
* Lav det sådan, at man fra konsol-applikationen kan trække for real på DFOS-APIet, så man ikke tilsyneladende hiver personer
  men derimod observing facilities. De skal jo i øvrigt have et navn. Eller også kunne du bare lave noget mapping, der er lidt
  mere clever - du kunne jo f.eks. trække en observing facility fra DFOS og så mappe den ind i et ANTAL Person objekter, hvor
  der jo så gerne skulle være en pr detail...
  Udviklingsarbejdet kan passende foregå på Linux'en for konsol-applikationen, men når det så virker, kan du passende køre det 
  over på WPF-applikationen og installere den på DOIT-maskinen.
  Frem for at mappe det over i Person kunne du jo altså også sætte en observing facility i søen..
  mnjaaah du kunne altså godt til en start udvide Person med at have lat long koordinater... selv om det lidt er noget svineri
  Til en start burde du altså lige hive din kort-applikation ind, skrælle den, og erstatte med "personer".
  PT så dealer den jo i en hel masse, hvor der også er child entiteter med... det skal skrælles ud
  Refaktorer den der API-plugin så det er mindre skrald-agtigt - rent faktisk bør du jo nok lave en ekstra, som ikke trækker på
  det sædvanlige API men derimod på DFOS

* Du bør have VIRKNINGSTID med for personer, så man ikke skal spole tilbage i tid for at se, hvad de f.eks. har heddet før.
  - Det skal nok være helt generelt, lige som det jo er for versioned object, så det hurtigt kan skrælles af, hvis man ikke
    er interesseret i virkningstid
  - Bemærk, at det, du jo har indtil videre har fået lavet med star wars karaktererne det essentielt er  et current situation system
  - Når du laver systemet om, så skal det vel være sådan, at der er flere objekter i spil, som alle er gældende, og som repræsenterer
    samme objekt. F.eks. skal der være ét objekt, der repræsenterer Anakin i perioden før han blev Sith og et andet objekt, som 
    repræsenterer ham i perioden efter, hvor han i øvrigt hed Darth Vader. Det er jo altså ikke sådan helt lige til, for Person er jo 
    altså en UAFHÆNGIG entitet, så hvordan skal man som bruger afklare, om 2 objekter med forskelligt ID repræsenterer samme person?
    Er man ikke reelt nødt til at have et parent objekt, der nærmest er tomt?.. Og er det ikke lige præcis det, der er tale om i WIGOS,
    hvor den entitet, der hedder AbstractEnvironmentalMonitoringFacility snart sagt ingen informationer har. For Person kunne man måske
    operere med en AbstractPerson. I DFOS gør de vel egentlig det samme, hvor de effektivt opererer med, at en Observing Facility sådan
    set bare er en samling af Details...
    ....De forskellige objekter har jo altså samme objekt id, dvs det er ikke unikt, men effektivt gælder der, at det i kombination
    med et virkningstidsinterval ikke må overlappe med andre virkningstidsintervaller for samme objekt
* Hvorfor får vi kun en person op med konsolapplikationen men 2 med WPF'en?
  -> Den funktionalitet, hvor du plukker det ene objekt, der svarer til time of interest, det ligger indtil videre kun i
     metoden PersonRepositoryFacade.GetAll. Du skal nok gøre den konstruktion generelt anvendelig, så du også kan bruge den i Find
* Reparer Glossary, C2IEDM og WIGOS
  -> Glossary er sgu lidt død i det - nok bedre at indlemme den som sit eget domæne i PR
  -> Wigos er repareret men nok en smule vingeskudt og det samme gælder formentlig for C2IEDM for

Løst og fast:
 Du er nået dertil, at man som bruger af en IUnitOfWorkFactory i vidt omfang kan abstrahere fra,
 om det er en "almindelig" en af slagsen, eller om det er en "wrapper" af en almindelig en, der 
 opererer på en database med versionshistorik.

 MEN.. hvis man opererer med en wrapper, er man ikke desto mindre nødt til at spørge efter Object IDs
 snarere end bare Ids. Det kunne være fedt, hvis man helt og aldeles kunne spørge efter Ids, og der
 så bare gjaldt, at når man opererede med en wrapper, så spurgte den reelt efter ObjectIds.

 Du var ude i en overvejelse om, om man kunne lade et VersionedObject returnere sit object id frem for 
 sit id, når det blev spurgt, men det er svært at gennemskue implikationerne

 Hvis man lavet sådan en lidt sofistikeret property, hvordan vil databasen så komme til at se ud?
 -> Det lader til at være fint.. Den skal bare have en Property, der er rigtig

 Hvilke komponenter skal tilgå ObjectId og hvornår?
 - PersonRepositoryFacade (Den dealer kun i versionerede dbs, så den ved godt, at der både er et Id og et ObjectId)
 - De forskellige ViewModeller, f.eks. MainWindowViewModel, PeoplePropertiesViewModel og PersonListViewModel

 Kunne man så ikke sige, at viewmodellerne ALTID bare spørger efter ID, og så får de altså bare et ObjectID,
 ude at de er skarpe på det? Facaden derimod, den må altså gerne spørge både efter Id og ObjectId...