Done:
* Man skal kunne operere med positions fra et file repo
  o Statiner OG Positions skal læses op i memory (OK)
  o Når man trykker på Find-knappen med country filter sat til Danmark, skal den hive 2140 stationer op (OK)
  o Den export, du har brugt til at lave StatDBFile Repo virker ikke, idet den har givet samme startinterval til alle
    (mon ikke det skyldes det der rod med cachen..) (OK)
* Man skal kunne køre stationfetcher fra DMI.Data.Studio og ikke bare fra DMI.SMS
* Lav en viewmodel med tilhørende view, der viser en TIDSSERIE for en valgt station under anvendelse af et af de plugins,
  der ligger under DMI.ObsDB
* Find lige ud af, hvad mekanismen er mht at hente tidsserier ind i tidsserie viewet, og opdater dokumentationen i dit Confluence
  space: DMI Data Studio.
  Mht at hive observationsdata trækkes der pt på plugin, der hedder DMI.ObsDB.Persistence.PostgreSQL, men man kan trække
  fra ethvert compliant plugin. DMI.ObsDB.Persistence.PostgreSQL gør det at den genererer SQL til at trække fra OBSDB, og
  så transformerer den data, så det passer med den generelle model (WMDR). Den er i øvrigt temmelig langsom.
  Den trækker i øvrigt indtil videre kun temp_dry. Det er mest relevant at kigge på de aktive synopstationer som f.eks. Gedser (6149)
* Den feature, der viser smalle gule bjælker for hvornår en station har foretaget målinger, skal basere sig på et DMI.ObsDB
  plugin og ikke på et file repo

In progress:
* Rund det nye Chronology2 view af, så det fuldt og helt kan erstatte det gamle
  - der er en problematik i at man først beregner barHeight, når viewporten er initialiseret - det kunne være hensigtsmæssigt,
    hvis man havde mulighed for at sætte vertikal skalering til 1, samtidig med at man beder den om selv at beregne horisontal
    skalering. Lige nu er det jo sådan at man definerer dimensionerne for sit World Window - både horisontalt og vertikalt,
    og så beregner den vertikal og horisontal skalering, så det kommer til at passe.
* Lav en kobling mellem det nye Chronology2 view og det andet tidsserie view, så man let kan inspicere en tidsserie

Todo:
* Lav et sqlite-plugin for StatDB
* Omdøb ObsDB-serien til Wigos
* Man skal kunne importere en json fil med statdb-data
* Det skal være lettere at finde specificere et tidsinterval for tidsserieviewet
* Progress feedback for den komponent, der genererer gule bjælker
* Stabiliser den komponent, der genererer gule bjælker
* Dokumenter mekanismen til at hente observationer passende i dit Confluence site
* Lav en feature, hvor man for de valgte stationer kan generere datafiler over de rå observationer samt filer over tidsintervaller
  - det må meget gerne ligge tilgængeligt i konsol-applikationen, så det kan køres fra Linux
* Gør det muligt at eksportere en tidsserie til WMDR-format
* Undersøg, om man kan refaktorere station fetcheren, så den også virker selv om man ændrer brugen
  - pt hiver du alle stationer op, som har det rigtige stationsid og den rigtige stationstype, og så sorterer du på
    gdb_from_date. Hvis du så laver nye data, så tolkes de som nye stationer, og så kommer der jo altså flere stationer med samme navn osv i listen
    .. måske kan du sige, at du i første omgang IKKE vil have stationer op, hvorom der gælder:
      * De er current (gdb_date = 9999)
      * de har en dateto
      * de har status som aktive
    (Der er nemlig ikke en eneste af de nuværende rækker, dvs under de gamle brugsregler, der matcher på dette)
  - Umiddelbart kløjs station fetcheren i det mht at generere virkningstidsintervaller, og det skyldes formentlig,
    at den gerne vil bruge gdb_to_date som afslutning på virkningstidsintervallet. Du kunne prøve at lave det om således at
    den plukker dateto frem for gdb_to_date, hvis den er der. Man kunne også gøre det endnu mere rent ved at benytte
    dette princip:
    - Når man traverserer historikken for en station, så skal man operere med, at en række kan tage PRÆCEDENS for en anden,
      dvs, at hvis en række har et virkningstidsinterval, som overlapper med en, der allerede er gælder, så ignoreres den.
      I praksis skulle man kunne nøjes med at sammenligne gdb_from_date med datefrom for seneste
* For station fetcheren skal man i brugergrænsefladen optionelt kunne angive en skæringsdato
* Genindfør det der med at man kan overlejre intervaller, hvor der er udført observationer
* Der skal være en minimum bredde for stationinformation list viewet eller måske snarere hele første kolonne
* Hvis man ikke har checket noget af i row condition filteret, skal det svare til, at man har checket det hele af



