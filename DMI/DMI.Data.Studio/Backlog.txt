Done:
* Man skal kunne operere med positions fra et file repo
  o Statiner OG Positions skal læses op i memory (OK)
  o Når man trykker på Find-knappen med country filter sat til Danmark, skal den hive 2140 stationer op (OK)
  o Den export, du har brugt til at lave StatDBFile Repo virker ikke, idet den har givet samme startinterval til alle
    (mon ikke det skyldes det der rod med cachen..) (OK)
* Man skal kunne køre stationfetcher fra DMI.Data.Studio og ikke bare fra DMI.SMS
* Lav en viewmodel med tilhørende view, der viser en TIDSSERIE for en valgt station under anvendelse af et af de plugins,
  der ligger under DMI.ObsDB
* Find lige ud af, hvad mekanismen er mht at hente tidsserier ind i tidsserie viewet, og opdater dokumentationen i dit Confluence
  space: DMI Data Studio.
  Mht at hive observationsdata trækkes der pt på plugin, der hedder DMI.ObsDB.Persistence.PostgreSQL, men man kan trække
  fra ethvert compliant plugin. DMI.ObsDB.Persistence.PostgreSQL gør det at den genererer SQL til at trække fra OBSDB, og
  så transformerer den data, så det passer med den generelle model (WMDR). Den er i øvrigt temmelig langsom.
  Den trækker i øvrigt indtil videre kun temp_dry. Det er mest relevant at kigge på de aktive synopstationer som f.eks. Gedser (6149)
* Den feature, der viser smalle gule bjælker for hvornår en station har foretaget målinger, skal basere sig på et DMI.ObsDB
  plugin og ikke på et file repo
* Man skal kun kunne vælge én station i stationslisten for statdb
* Fix det med at den risikerer at fucke med skalering i det nye kronologiske view
* Der skal være mulighed for at undlade at opdatere tidsserie viewet
* Introducer et mode, hvor, når man vælge én station i sms, så sker der følgende for stationsliste viewet:
  1) StationID Filteret initialiseres med samme stationsid
  2) Find eksekveres
  3) Hvis en af de stationer, der returneres, er det stationsid man forventer, så selectes den automatisk, således at det kronologiske view populeres
* Observationsbjælker skal kun vises for Position bjælker hentet fra statdb
* Når man genererer gule bjælker, foregår det ved at der læses observationer for et år ad gangen. Observationerne samles i en kæmpe collection in memory,
  som så fodres til en algoritme, der producerer en chunks fil - det går der for lang tid med. Det vil være bedre, hvis man genererede en chunks 
  fil for hvert år og så sluttede af med at samle dem i en samlet chunks fil.

In progress:
* Der skal være mulighed for i Gant-viewet at vise hvor stort afstanden er mellem forskellige lokationer
  - Tegn en label mellem position bjælker (ok)
  - Pågældende label skal tegnes med en farve, som man selv vælger (det skal måske være en specialiseret label)

* Frem for at bruge filteret for SMS skal der være mulighed for at bruge en custom liste, der læses fra en settingsfil
* Der skal være support for flere parametre end bare precip_10min eller temp_dry
* Der skal være en filter-setting, der muliggøt udtræk af netop de stationer, der indgår i nedbørsberegningerne
* Der skal være mulighed for at de stationer, der fremsøges i sms, ledes direkte over i listen over stationer i statdb, så man ikke skal "plukke" dem
* Vis forskellen i position med en lille label, når man i det nye kronologiske view skifter til en ny position
* Fix det issue, der er med at den tilsyneladende ikke respekterer, når man sætter WorldWindowBottomRightLimit sent
  - kan du reproducere det i Craft.GuiTest?
* Rund det nye Chronology2 view af, så det fuldt og helt kan erstatte det gamle
  - der er en problematik i at man først beregner barHeight, når viewporten er initialiseret - det kunne være hensigtsmæssigt,
    hvis man havde mulighed for at sætte vertikal skalering til 1, samtidig med at man beder den om selv at beregne horisontal
    skalering. Lige nu er det jo sådan at man definerer dimensionerne for sit World Window - både horisontalt og vertikalt,
    og så beregner den vertikal og horisontal skalering, så det kommer til at passe.
* Lav en kobling mellem det nye Chronology2 view og det andet tidsserie view, så man let kan inspicere en tidsserie

Todo:
* Der bør opereres med cancelling, hvis en bruger vælger en anden station mens den er i gang med at hente observationer for en af dem
* Hvis man inspicerer en længere tidsperiode og derfor får flere tusinde observationer vist, så skal den ikke lave et punkt pr måling men hellere klumpe dem sammen somehow
* Det skal vises anderledes, når der er et gap mellem målinger
* Man skal kunne se tidspunkt for hvor cursoren er i det kronologiske view
* Lav et sqlite-plugin for StatDB
* Omdøb ObsDB-serien til Wigos
* Man skal kunne importere en json fil med statdb-data
* Det skal være lettere at finde specificere et tidsinterval for tidsserieviewet
* Progress feedback for den komponent, der genererer gule bjælker
* Stabiliser den komponent, der genererer gule bjælker
* Dokumenter mekanismen til at hente observationer passende i dit Confluence site
* Lav en feature, hvor man for de valgte stationer kan generere datafiler over de rå observationer samt filer over tidsintervaller
  - det må meget gerne ligge tilgængeligt i konsol-applikationen, så det kan køres fra Linux
* Gør det muligt at eksportere en tidsserie til WMDR-format
* Undersøg, om man kan refaktorere station fetcheren, så den også virker selv om man ændrer brugen
  - pt hiver du alle stationer op, som har det rigtige stationsid og den rigtige stationstype, og så sorterer du på
    gdb_from_date. Hvis du så laver nye data, så tolkes de som nye stationer, og så kommer der jo altså flere stationer med samme navn osv i listen
    .. måske kan du sige, at du i første omgang IKKE vil have stationer op, hvorom der gælder:
      * De er current (gdb_date = 9999)
      * de har en dateto
      * de har status som aktive
    (Der er nemlig ikke en eneste af de nuværende rækker, dvs under de gamle brugsregler, der matcher på dette)
  - Umiddelbart kløjs station fetcheren i det mht at generere virkningstidsintervaller, og det skyldes formentlig,
    at den gerne vil bruge gdb_to_date som afslutning på virkningstidsintervallet. Du kunne prøve at lave det om således at
    den plukker dateto frem for gdb_to_date, hvis den er der. Man kunne også gøre det endnu mere rent ved at benytte
    dette princip:
    - Når man traverserer historikken for en station, så skal man operere med, at en række kan tage PRÆCEDENS for en anden,
      dvs, at hvis en række har et virkningstidsinterval, som overlapper med en, der allerede er gælder, så ignoreres den.
      I praksis skulle man kunne nøjes med at sammenligne gdb_from_date med datefrom for seneste
* For station fetcheren skal man i brugergrænsefladen optionelt kunne angive en skæringsdato
* Genindfør det der med at man kan overlejre intervaller, hvor der er udført observationer
* Der skal være en minimum bredde for stationinformation list viewet eller måske snarere hele første kolonne
* Hvis man ikke har checket noget af i row condition filteret, skal det svare til, at man har checket det hele af



